3 ІНЖЕНЕРНІ РІШЕННЯ
3.1 Структура та технології проєкту
Платформа .NET 8 була обрана для розробки серверної частини, оскільки вона відповідає всім функціональним вимогам нашої системи. REST специфікація, яка зорієнтована на використання веб-ресурсів, ідентифікованих через URL, стала фундаментом архітектури веб-сервісів, реалізованих за допомогою контролерів у ASP.NET Core. Для зберігання даних було обрано MS SQL Server, з огляду на його гнучкість у керуванні даними, високу продуктивність та надійність. Завдяки можливостям MS SQL, система здатна ефективно масштабуватися з урахуванням збільшення обсягів даних, а також забезпечувати оперативний доступ до інформації. 
Взаємодія серверної частини з базою даних відбувається через Entity Framework. Інтерфейси REST API забезпечують комунікацію між сервером та клієнтами, які включають веб-додатки, мобільні додатки та пристрої IoT. Опис цієї взаємодії та інтеграції з різними компонентами системи можна знайти на UML-діаграмі розгортання, представленій на рисунку 3.1.
	
Інтеграція даних з IoT-пристроїв теж буде виконуватися через Rest API. Для наочного представлення процесу взаємодії між IoT-пристроями та сервером, було створено UML-діаграму діяльності (див. рис. 3.2). Процес працює циклічним чином, котрий розпочинається, коли пацієнт здійснює прийом ліків за допомогою розумного пристрою. Після кожного прийому ліків пристрій автоматично реєструє факт прийому та стан залишку ліків у контейнері. Пристрій ініціює відправлення POST-запиту з відповідними даними до сервера системи. Коли сервер отримує цей запит, він перевіряє отриману інформацію, порівнюючи її з попередніми даними про прийом ліків та з встановленим розкладом. У випадку, якщо зафіксовано пропуск дози або якщо залишок ліків наближається до критичного рівня, система створює відповідні повідомлення для пацієнта, родича або лікаря, залежно від серйозності ситуації. Далі сервер оновлює історію прийому ліків пацієнта в базі даних, зберігаючи всі деталі про час прийому, кількість залишку та інші релевантні дані. Таким чином, інтеграція розумних пристроїв із системою "MediReminder" забезпечує безперервний моніторинг стану ліків та дотримання режиму прийому, що значно підвищує ефективність лікування та своєчасність втручання у разі необхідності.
 
Аналізуючи архітектуру серверної секції (див. рис. 3.3), слід підкреслити, що вона утворена з шести основних взаємозалежних компонентів.

Кожен з наведених компонентів відповідає на власний функціонал:
– Компонент «Models» містить класи доменних моделей, які визначають структуру даних та їхні взаємовідносини в базі даних.
– Компонент «Interfaces» оголошує інтерфейси, що визначають контракти для компоненту «Repository», забезпечуючи відділення реалізації від абстракції.
– Компонент «Repository» реалізує патерн репозиторіїв, надаючи абстракцію для доступу до даних для компоненту «Controllers», що дозволяє виконувати операції з базою даних.
– Компонент «Dto» (Data Transfer Objects) використовується для інкапсуляції даних і передачі їх між процесами, зокрема від сервера до клієнта.
– Компонент «PostDto» використовується схожим чином як компонент «Dto», але для обробки POST-запитів для деяких моделей.
– Компонент «Controllers» відповідає за обробку вхідних HTTP запитів, виклик відповідних методів репозиторіїв та повернення відповідей клієнту.

3.2 Специфікація REST API

Модель	Тип методу	Посилання	Дія
Адміністратор	GET	/api/Administrators	Отримання записів всіх адміністраторів
		/api/Administrators/{adminId}	Отримання запису конкретного адміністратора за ідентифікатором
		/api/Administrators/email/{email}	Отримання запису конкретного адміністратора за поштовою скринею
	POST	/api/Administrators/{adminId}	Створення нового запису адміністратора
	PUT	/api/Administrators/{adminId}	Оновлення запису конкретного адміністратора
	DELETE	/api/Administrators/{adminId}	Видалення запису конкретного адміністратора
		/api/Administrators/acc/{adminId}	Видалення запису конкретного адміністратора та його акаунту
Лікар	GET	/api/Doctors/	Отримання записів всіх лікарів
		/api/Doctors/{doctorId}	Отримання запису конкретного лікаря за ідентифікатором
		/api/Doctors/email/{email}	Отримання запису конкретного лікаря за поштовою скринею
		/api/Doctors/patients/{doctorId}	Отримання запису всіх пацієнтів, що є пов’язаними із конкретним лікарем
	POST	/api/Doctors	Створення нового запису лікаря
	PUT	/api/Doctors/{doctorId}	Оновлення запису конкретного лікаря
	DELETE	/api/Doctors/{doctorId}	Видалення запису конкретного лікаря
		/api/Doctors/acc/{doctorId}	Видалення запису конкретного лікаря та його акаунту
Розклад прийому ліків 	GET	/api/MedicationSchedules/	Отримання записів всіх розкладів
		/api/MedicationSchedules/{msheduleId}	Отримання запису конкретного розкладу за ідентифікатором
		/api/MedicationSchedules/patient/{patientId}	Отримання записів всіх розкладів, що є пов’язаними із конкретним пацієнтом
	POST	/api/MedicationSchedules	Створення нового запису розкладу
	PUT	/api/MedicationSchedules/{msheduleId}	Оновлення запису конкретного розкладу
	DELETE	/api/MedicationSchedules/{msheduleId}	Видалення запису конкретного розкладу
Статистика прийому ліків	GET	/api/MedicationStatistics/	Отримання записів всієї статистики
		/api/MedicationStatistics/{mstatisticsId}	Отримання запису конкретної статистики за ідентифікатором
		/api/MedicationStatistics/patient/{patientId}	Отримання записів всієї статистики, що є пов’язаними із конкретним пацієнтом
	POST	/api/MedicationStatistics	Створення нової статистики
	PUT	/api/MedicationStatistics/{mstatisticsId}	Оновлення запису конкретної статистики
	DELETE	/api/MedicationStatistics/{mstatisticsId}	Видалення запису конкретної статистики
Ліки	GET	/api/Medicine/	Отримання записів всіх
ліків
		/api/Medicine/{medicineId}	Отримання запису конкретних ліків
		/api/Medicine/patient/{patientId}	Отримання записів всіх ліків, що є пов’язаними із конкретним пацієнтом
	POST	/api/Medicine	Створення нових ліків
	PUT	/api/Medicine/{medicineId}	Оновлення запису конкретних ліків
	DELETE	/api/Medicine/{medicineId}	Видалення запису конкретних ліків
Повідомлення	GET	/api/Message/	Отримання записів всіх
повідомлень
		/api/Message/{messageId}	Отримання запису конкретного повідомлення
		/api/Message/user/{userId}	Отримання записів всіх повідомлень, що є пов’язаними із конкретним користувачем
	POST	/api/Message	Створення нового повідомлення
	PUT	/api/Message/{messageId}	Оновлення запису конкретного повідомлення
	DELETE	/api/Message/{messageId}	Видалення запису конкретного повідомлення
Тип повідомлення	GET	/api/MessageType/	Отримання записів всіх типів
повідомлень
		/api/MessageType/{messageTypeId}	Отримання запису конкретного типу повідомлення
		/api/MessageType/messages/{messageTypeId}	Отримання записів всіх повідомлень, що є пов’язаними із конкретним типом повідомлень
	POST	/api/MessageType	Створення нового типу повідомлення
	PUT	/api/MessageType/{messageTypeId}	Оновлення запису конкретного типу повідомлення
	DELETE	/api/MessageType/{messageTypeId}	Видалення запису конкретного типу повідомлення
Пацієнт	Get	/api/Patients/	Отримання записів всіх пацієнтів
		/api/Patients/{doctorId}	Отримання запису конкретного пацієнта за ідентифікатором
		/api/Patients/email/{email}	Отримання запису конкретного пацієнта за поштовою скринею
		/api/Patients/
messages/{patientId}	Отримання запису всіх повідомлень, що є пов’язаними із конкретним пацієнтом
		/api/Patients/
medicines/{patientId}	Отримання запису всіх ліків, що є пов’язаними із конкретним пацієнтом
		/api/Patients/medication-schedules/{patientId}	Отримання запису всіх розкладів, що є пов’язаними із конкретним пацієнтом
		/api/Patients/medication-statistics/{patientId}	Отримання запису всієї статистики, що є пов’язаною із конкретним пацієнтом
		/api/Patients/
doctors/{patientId}	Отримання запису всіх лікарів, що є пов’язаними із конкретним пацієнтом
		/api/Patients/
trustees/{patientId}	Отримання запису всіх опікунів, що є пов’язаними із конкретним пацієнтом
	POST	/api/Patients	Створення нового запису пацієнта
	PUT	/api/Patients/{patientId}	Оновлення запису конкретного пацієнта
	DELETE	/api/Patients/{patientId}	Видалення запису конкретного пацієнта
		/api/Patients/acc/{patientId}	Видалення запису конкретного пацієнта та його акаунту
Пацієнт-Лікар	POST	/api/PatientDoctors	Створення нового запису зв’язку «Пацієнт-Лікар»
	PUT	/api/PatientDoctors/{patientId, doctorId}	Оновлення запису конкретного зв’язку «Пацієнт-Лікар»
	DELETE	/api/PatientDoctors/{patientId, doctorId}	Видалення запису конкретного зв’язку «Пацієнт-Лікар»
Пацієнт-Опікун	POST	/api/PatientTrustees	Створення нового запису зв’язку «Пацієнт-Опікун»
	PUT	/api/PatientTrustees/{patientId, trusteeId}	Оновлення запису конкретного зв’язку «Пацієнт- Опікун»
	DELETE	/api/PatientTrustees/{patientId, trusteeId}	Видалення запису конкретного зв’язку «Пацієнт- Опікун»
Розумний пристрій	GET	/api/SmartDevices	Отримання записів всіх розумних пристроїв
		/api/SmartDevices/{smartDeviceId}	Отримання запису конкретного розумного пристрою за ідентифікатором
	POST	/api/SmartDevices/{smartDeviceId}	Створення нового запису розумного пристрою
	PUT	/api/SmartDevices/{smartDeviceId}	Оновлення запису конкретного розумного пристрою
	DELETE	/api/SmartDevices/{smartDeviceId}	Видалення запису конкретного розумного пристрою
Тип розумного пристрою	GET	/api/SmartDeviceTypes	Отримання записів всіх типів розумних пристроїв
		/api/SmartDeviceTypes/{smartDeviceTypeId}	Отримання запису конкретного типу розумного пристрою за ідентифікатором
		/api/SmartDeviceTypes/smartDevices/{smartDeviceTypeId}	Отримання запису всіх розумних пристроїв, що є пов’язаними із конкретним типом розумного пристрою
	POST	/api/SmartDeviceTypes/{smartDeviceTypeId}	Створення нового запису типу розумного пристрою
	PUT	/api/SmartDeviceTypes/{smartDeviceTypeId}	Оновлення запису конкретного типу розумного пристрою
	DELETE	/api/SmartDeviceTypes/{smartDeviceTypeId}	Видалення запису конкретного типу розумного пристрою
Опікун / Родич	GET	/api/Trustees/	Отримання записів всіх опікунів
		/api/Trustees/{trusteeId}	Отримання запису конкретного опікуна за ідентифікатором
		/api/Trustees/email/{email}	Отримання запису конкретного опікуна за поштовою скринею
		/api/Trustees/
patients/{trusteeId}	Отримання запису всіх пацієнтів, що є пов’язаними із конкретним опікуном
	POST	/api/Trustees	Створення нового запису опікуна
	PUT	/api/Trustees/{trusteeId}	Оновлення запису конкретного опікуна
	DELETE	/api/Trustees/{trusteeId}	Видалення запису конкретного опікуна
		/api/Trustees/acc/{trusteeId}	Видалення запису конкретного опікуна та його акаунту
Акаунт користувача	POST	/api/Accounts/
register-admin	Створення нового запису користувача типу «Адміністратор»
		/api/Accounts/
register-trustee	Створення нового запису користувача типу «Опікун»
		/api/Accounts/
register-doctor	Створення нового запису користувача типу «Лікар»
		/api/Accounts/
register-patient	Створення нового запису користувача типу «Пацієнт»
		/api/Accounts/login	Авторизація зареєстрованого користувача до системи

3.3 Ланцюжок «Модель-Інтерфейс-Репозиторій-Контролер». Модель

Кожна сутність розпочинається зі створення її моделі. Основна мета подібної моделі полягає у відображенні даних, у наведеному прикладі, пацієнта. Клас Patient відображає основні характеристики пацієнта та його зв'язки з іншими сутностями системи. 
Клас Patient включає унікальний ідентифікатор пацієнта PatientId (див. рядок 5, розділ А.1 у додатку А). Поле ApplicationUser (див. рядок 6, розділ А.1 у додатку А) відображає зв'язок з користувачем системи, що представляє дані про користувача, зокрема його облікові дані та права доступу. Поле Address (див. рядок 7, розділ А.1 у додатку А) зберігає адресу проживання пацієнта, що може бути використана для контактних та адміністративних цілей. Поле Age (див. рядок 8, розділ А.1 у додатку А) відображає вік пацієнта, а Gender (див. рядок 9, розділ А.1 у додатку А) визначає стать пацієнта, що є важливою інформацією для медичних записів.
Також клас має декілька колекцій, що відображають зв'язки з іншими сутностями системи. Поле SmartDevices (див. рядок 10, розділ А.1 у додатку А) містить колекцію розумних пристроїв, пов'язаних з пацієнтом, що дозволяє відстежувати ці самі пристрої. Поле Messages (див. рядок 11, розділ А.1 у додатку А) зберігає колекцію повідомлень, що отримує пацієнт, включаючи сповіщення та нагадування. Поле Medicines (див. рядок 12, розділ А.1 у додатку А) відображає колекцію ліків, що приймає пацієнт, що є ключовою частиною медичної інформаційної системи для відстеження призначених медикаментів. Поле MedicationSchedules (див. рядок 13, розділ А.1 у додатку А) містить розклад прийому ліків, що дозволяє системі нагадувати пацієнту про час прийому ліків та стежити за дотриманням графіку лікування. Поле MedicationStatistics (див. рядок 14, розділ А.1 у додатку А) зберігає статистику прийому ліків, що дозволяє відстежувати ефективність лікування та виявляти будь-які відхилення. 
Поле PatientDoctors (див. рядок 15, розділ А.1 у додатку А) відображає зв'язок "багато-до-багатьох" між пацієнтами та лікарями, дозволяючи кожному пацієнту мати декілька лікарів, а кожному лікарю мати декілька пацієнтів. Поле PatientTrustees (див. рядок 16, розділ А.1 у додатку А) відображає зв'язок "багато-до-багатьох" між пацієнтами та опікунами, що дозволяє опікунам отримувати доступ до медичної інформації пацієнтів та допомагати в управлінні їх лікуванням. 
Завдяки наявності різноманітних властивостей та зв'язків, клас Patient може бути інтегрований з різними зовнішніми системами. Загалом, клас надає структуровану, безпечну та ефективну основу для керування інформацією про пацієнтів.

3.4 Ланцюжок «Модель-Інтерфейс-Репозиторій-Контролер». Інтерфейс

Інтерфейс IPatientRepository, що є частиною проекту mediremineder, відіграє ключову роль у визначенні контрактів для взаємодії з даними пацієнтів в системі. Розглянемо детальніше цей інтерфейс та його методи. Загалом інтерфейс IPatientRepository (див. рядки 6-22, розділ А.2 у додатку А) є частиною шару доступу до даних (Data Access Layer) і визначає набір операцій, які можна виконувати над об'єктами типу Patient.
У системі IPatientRepository відіграє центральну роль щодо забезпечення відділення бізнес-логіки від безпосередньої роботи з базою даних. Це полегшує тестування та підтримку коду, а також забезпечує можливість заміни конкретних реалізацій без впливу на загальну функціональність системи. Крім того, використання інтерфейсу дозволяє легше адаптуватися до змін у бізнес-вимогах та технологічному стеку.

3.5 Ланцюжок «Модель-Інтерфейс-Репозиторій-Контролер». Репозиторій

Клас PatientRepository має критично важливе значення для взаємодії з даними пацієнтів і виконує роль посередника між базою даних і бізнес-логікою програми. Основні аспекти та відповідальності цього репозиторія розпочинаються з конструктора PatientRepository (див. рядки 12-15, розділ А.3 у додатку А), де виконується ін'єкція залежності DataContext, що є контекстом бази даних. Це дозволяє репозиторію взаємодіяти з базою даних для виконання операцій CRUD (створення, читання, оновлення, видалення) над даними пацієнтів. 
Методи для операцій з даними, такі як CreatePatient та DeletePatient (див. рядки 17-27, розділ А.3 у додатку А), відповідають за додавання нових пацієнтів та видалення існуючих пацієнтів з бази даних. Методи забезпечують ефективне керування даними, використовуючи базові операції з контекстом бази даних. Методи GetDoctorsByPatient, GetMedicationSchedulesByPatient, GetMedicationStatisticsByPatient, GetMedicinesByPatient, GetMessagesByPatient (див. рядки 29-53, розділ А.3 у додатку А) та GetTrusteesByPatient (див. рядки 79-83, розділ А.3 у додатку А) забезпечують отримання відповідних записів, пов'язаних з конкретним пацієнтом. Ці методи використовують запити LINQ для отримання даних з різних таблиць, пов'язаних з пацієнтами, що дозволяє забезпечити ефективний доступ до даних.
Методи GetPatient, GetPatientByEmail, GetPatients (див. рядки 55-77, розділ А.3 у додатку А) використовуються для отримання інформації про одного пацієнта або про всіх пацієнтів відповідно. Використання методів включення (Include) у запитах забезпечує завантаження пов'язаних даних разом з основними об'єктами.
Методи PatientExists та PatientExistsByEmail (див. рядки 85-93, розділ А.3 у додатку А) перевіряють наявність пацієнта в базі даних за ідентифікатором або електронною поштою. Це дозволяє швидко перевіряти існування записів без необхідності завантаження всіх даних пацієнта.
Метод Save (див. рядки 95-99, розділ А.3 у додатку А) використовується для збереження змін у базі даних. Він викликає метод SaveChanges контексту бази даних і повертає результат операції, що дозволяє визначити успішність збереження.
Метод UpdatePatient (див. рядки 101-105, розділ А.3 у додатку А) оновлює дані існуючого пацієнта, використовуючи метод Update контексту бази даних. Це забезпечує можливість оновлення даних пацієнта в системі. 
Тож репозиторій служить як абстрактний шар між бізнес-логікою програми та операціями з базою даних, дозволяючи ізолювати логіку роботи з даними від інших частин системи. Завдяки відокремленню від бази даних, тестування логіки програми стає простішим і більш ефективним, оскільки можна використовувати заміщення або макетування бази даних. Використання репозиторію дозволяє легко адаптувати систему до змін у вимогах або технологіях, оскільки вся логіка взаємодії з даними зосереджена в одному місці.
Таким чином, репозиторії відіграють вирішальну роль у структурі та функціонуванні програми, забезпечуючи ефективний та надійний спосіб керування даними моделей.

3.6 Ланцюжок «Модель-Інтерфейс-Репозиторій-Контролер». Контролер

Клас PatientController, розташований в просторі імен, відіграє центральну роль у обробці HTTP запитів, пов'язаних з управлінням даними пацієнтів у системі. 
Цей контролер використовує шаблон проектування MVC, що дозволяє відокремлювати логіку обробки даних від користувацького інтерфейсу. У конструкторі класу (див. рядки 20-28, розділ А.4 у додатку А) відбувається ін'єкція залежностей для репозиторію IPatientRepository, менеджера користувачів UserManager<ApplicationUser> та сервісу IMapper, що забезпечує легкий доступ до даних пацієнтів та інструментів для трансформації даних (мапінгу). 
Контролер надає методи для створення (CreatePatient) (див. рядки 162-182, розділ А.4 у додатку А), читання (GetPatients, GetPatient, GetPatientByEmail, GetMessagesByPatient, GetMedicinesByPatient, GetMedicationSchedulesByPatient, GetMedicationStatisticsByPatient, GetDoctorsByPatient, GetTrusteesByPatient) (див. рядки 30-160, розділ А.4 у додатку А), оновлення (UpdatePatient) (див. рядки 184-219, розділ А.4 у додатку А) та видалення (DeletePatient, DeletePatientAndAccount) (див. рядки 221-270, розділ А.4 у додатку А) даних пацієнтів.
Ці методи відповідають стандартам RESTful веб-сервісів. Методи HttpGet, HttpPost, HttpPut, HttpDelete використовуються для обробки відповідних типів HTTP запитів. Вони забезпечують взаємодію з користувачами через HTTP протокол, дозволяючи їм здійснювати операції з даними пацієнтів. Сервіс IMapper використовується для трансформації об'єктів між моделями домену (Patient) та моделями передачі даних (DTOs) (див. розділ А.5 у додатку А). Це забезпечує безпеку та ізоляцію даних, які передаються між сервером та клієнтом, запобігаючи витоку чутливої інформації.
Також в контролері використовується перевірка стану моделі (ModelState.IsValid) для забезпечення коректності даних, які надходять від користувачів. Контролер дозволяє користувачам системи виконувати усі необхідні операції з даними пацієнтів, забезпечуючи централізований та стандартизований спосіб взаємодії.
Завдяки використанню REST API, PatientController може легко інтегруватися з іншими системами та сервісами, наприклад, з мобільними додатками або іншими веб-сервісами.
